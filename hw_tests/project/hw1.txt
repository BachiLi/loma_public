
Forward differentiation of function d_array_in_struct:
def d_array_in_struct(f : In[_dFoo]) -> _dfloat:
	return make__dfloat((int2float(((f).int_arr)[(int)(0)])) + ((((f).float_arr)[(int)(0)]).val),((float)(0.0)) + ((((f).float_arr)[(int)(0)]).dval))

Generated C code:

#include <math.h>
        
typedef struct {
	int* int_arr;
	float* float_arr;
} Foo;
typedef struct {
	float val;
	float dval;
} _dfloat;
typedef struct {
	int* int_arr;
	_dfloat* float_arr;
} _dFoo;
float array_in_struct(Foo f);
_dfloat d_array_in_struct(_dFoo f);
_dfloat make__dfloat(float val, float dval);
float array_in_struct(Foo f) {
	return ((float)(((f).int_arr)[(int)(0)])) + (((f).float_arr)[(int)(0)]);
}
_dfloat d_array_in_struct(_dFoo f) {
	return make__dfloat(((float)(((f).int_arr)[(int)(0)])) + ((((f).float_arr)[(int)(0)]).val),((float)(0.0)) + ((((f).float_arr)[(int)(0)]).dval));
}
_dfloat make__dfloat(float val, float dval) {
	_dfloat ret;
	ret.val = 0;
	ret.dval = 0;
	(ret).val = val;
	(ret).dval = dval;
	return ret;
}


Forward differentiation of function d_array_input:
def d_array_input(x : In[Array[_dfloat]]) -> _dfloat:
	return make__dfloat((((x)[(int)(0)]).val) + (((x)[(int)(1)]).val),(((x)[(int)(0)]).dval) + (((x)[(int)(1)]).dval))

Generated C code:

#include <math.h>
        
typedef struct {
	float val;
	float dval;
} _dfloat;
float array_input(float* x);
_dfloat d_array_input(_dfloat* x);
_dfloat make__dfloat(float val, float dval);
float array_input(float* x) {
	return ((x)[(int)(0)]) + ((x)[(int)(1)]);
}
_dfloat d_array_input(_dfloat* x) {
	return make__dfloat((((x)[(int)(0)]).val) + (((x)[(int)(1)]).val),(((x)[(int)(0)]).dval) + (((x)[(int)(1)]).dval));
}
_dfloat make__dfloat(float val, float dval) {
	_dfloat ret;
	ret.val = 0;
	ret.dval = 0;
	(ret).val = val;
	(ret).dval = dval;
	return ret;
}


Forward differentiation of function d_array_input_indexing:
def d_array_input_indexing(x : In[Array[_dfloat]], i : In[int], j : In[_dfloat]) -> _dfloat:
	return make__dfloat((((((x)[i]).val) + (((x)[float2int((j).val)]).val)) + (((x)[((int)(2)) * (i)]).val)) + (((x)[((int)(2)) * (float2int((j).val))]).val),(((((x)[i]).dval) + (((x)[float2int((j).val)]).dval)) + (((x)[((int)(2)) * (i)]).dval)) + (((x)[((int)(2)) * (float2int((j).val))]).dval))

Generated C code:

#include <math.h>
        
typedef struct {
	float val;
	float dval;
} _dfloat;
float array_input_indexing(float* x, int i, float j);
_dfloat d_array_input_indexing(_dfloat* x, int i, _dfloat j);
_dfloat make__dfloat(float val, float dval);
float array_input_indexing(float* x, int i, float j) {
	return ((((x)[i]) + ((x)[(int)(j)])) + ((x)[((int)(2)) * (i)])) + ((x)[((int)(2)) * ((int)(j))]);
}
_dfloat d_array_input_indexing(_dfloat* x, int i, _dfloat j) {
	return make__dfloat((((((x)[i]).val) + (((x)[(int)((j).val)]).val)) + (((x)[((int)(2)) * (i)]).val)) + (((x)[((int)(2)) * ((int)((j).val))]).val),(((((x)[i]).dval) + (((x)[(int)((j).val)]).dval)) + (((x)[((int)(2)) * (i)]).dval)) + (((x)[((int)(2)) * ((int)((j).val))]).dval));
}
_dfloat make__dfloat(float val, float dval) {
	_dfloat ret;
	ret.val = 0;
	ret.dval = 0;
	(ret).val = val;
	(ret).dval = dval;
	return ret;
}


Forward differentiation of function d_array_output:
def d_array_output(x : In[_dfloat], y : Out[Array[_dfloat]]) -> void:
	(y)[(int)(0)] = make__dfloat(((x).val) * ((x).val),(((x).val) * ((x).dval)) + (((x).dval) * ((x).val)))
	(y)[(int)(1)] = make__dfloat((((x).val) * ((x).val)) * ((x).val),((((x).val) * ((x).val)) * ((x).dval)) + (((((x).val) * ((x).dval)) + (((x).dval) * ((x).val))) * ((x).val)))

Generated C code:

#include <math.h>
        
typedef struct {
	float val;
	float dval;
} _dfloat;
void array_output(float x, float* y);
void d_array_output(_dfloat x, _dfloat* y);
_dfloat make__dfloat(float val, float dval);
void array_output(float x, float* y) {
	(y)[(int)(0)] = (x) * (x);
	(y)[(int)(1)] = ((x) * (x)) * (x);
}
void d_array_output(_dfloat x, _dfloat* y) {
	(y)[(int)(0)] = make__dfloat(((x).val) * ((x).val),(((x).val) * ((x).dval)) + (((x).dval) * ((x).val)));
	(y)[(int)(1)] = make__dfloat((((x).val) * ((x).val)) * ((x).val),((((x).val) * ((x).val)) * ((x).dval)) + (((((x).val) * ((x).dval)) + (((x).dval) * ((x).val))) * ((x).val)));
}
_dfloat make__dfloat(float val, float dval) {
	_dfloat ret;
	ret.val = 0;
	ret.dval = 0;
	(ret).val = val;
	(ret).dval = dval;
	return ret;
}


Forward differentiation of function d_array_output_indexing:
def d_array_output_indexing(x : In[_dfloat], i : In[int], j : In[_dfloat], y : Out[Array[_dfloat]]) -> void:
	(y)[i] = make__dfloat((x).val,(x).dval)
	(y)[float2int((j).val)] = make__dfloat((int2float((int)(2))) * ((x).val),((int2float((int)(2))) * ((x).dval)) + (((float)(0.0)) * ((x).val)))
	(y)[((int)(2)) * (i)] = make__dfloat((int2float((int)(3))) * ((x).val),((int2float((int)(3))) * ((x).dval)) + (((float)(0.0)) * ((x).val)))
	(y)[((int)(2)) * (float2int((j).val))] = make__dfloat((int2float((int)(4))) * ((x).val),((int2float((int)(4))) * ((x).dval)) + (((float)(0.0)) * ((x).val)))

Generated C code:

#include <math.h>
        
typedef struct {
	float val;
	float dval;
} _dfloat;
void array_output_indexing(float x, int i, float j, float* y);
void d_array_output_indexing(_dfloat x, int i, _dfloat j, _dfloat* y);
_dfloat make__dfloat(float val, float dval);
void array_output_indexing(float x, int i, float j, float* y) {
	(y)[i] = x;
	(y)[(int)(j)] = ((float)((int)(2))) * (x);
	(y)[((int)(2)) * (i)] = ((float)((int)(3))) * (x);
	(y)[((int)(2)) * ((int)(j))] = ((float)((int)(4))) * (x);
}
void d_array_output_indexing(_dfloat x, int i, _dfloat j, _dfloat* y) {
	(y)[i] = make__dfloat((x).val,(x).dval);
	(y)[(int)((j).val)] = make__dfloat(((float)((int)(2))) * ((x).val),(((float)((int)(2))) * ((x).dval)) + (((float)(0.0)) * ((x).val)));
	(y)[((int)(2)) * (i)] = make__dfloat(((float)((int)(3))) * ((x).val),(((float)((int)(3))) * ((x).dval)) + (((float)(0.0)) * ((x).val)));
	(y)[((int)(2)) * ((int)((j).val))] = make__dfloat(((float)((int)(4))) * ((x).val),(((float)((int)(4))) * ((x).dval)) + (((float)(0.0)) * ((x).val)));
}
_dfloat make__dfloat(float val, float dval) {
	_dfloat ret;
	ret.val = 0;
	ret.dval = 0;
	(ret).val = val;
	(ret).dval = dval;
	return ret;
}


Forward differentiation of function d_assign:
def d_assign(x : In[_dfloat], y : In[_dfloat]) -> _dfloat:
	z : _dfloat
	z = make__dfloat(((x).val) + ((y).val),((x).dval) + ((y).dval))
	return make__dfloat((z).val,(z).dval)

Generated C code:

#include <math.h>
        
typedef struct {
	float val;
	float dval;
} _dfloat;
float assign(float x, float y);
_dfloat d_assign(_dfloat x, _dfloat y);
_dfloat make__dfloat(float val, float dval);
float assign(float x, float y) {
	float z;
	z = 0;
	z = (x) + (y);
	return z;
}
_dfloat d_assign(_dfloat x, _dfloat y) {
	_dfloat z;
	z.val = 0;
	z.dval = 0;
	z = make__dfloat(((x).val) + ((y).val),((x).dval) + ((y).dval));
	return make__dfloat((z).val,(z).dval);
}
_dfloat make__dfloat(float val, float dval) {
	_dfloat ret;
	ret.val = 0;
	ret.dval = 0;
	(ret).val = val;
	(ret).dval = dval;
	return ret;
}


Forward differentiation of function d_call:
def d_call(x : In[_dfloat]) -> _dfloat:
	z0 : _dfloat = make__dfloat(sin((x).val),(cos((x).val)) * ((x).dval))
	z1 : _dfloat = make__dfloat((cos((z0).val)) + ((float)(1.0)),(((sin((z0).val)) * ((z0).dval)) * ((float)(-1.0))) + ((float)(0.0)))
	z2 : _dfloat = make__dfloat(sqrt((z1).val),(((float)(0.5)) * ((z1).dval)) / (sqrt((z1).val)))
	z3 : _dfloat = make__dfloat(pow((z2).val,(z1).val),((((z2).dval) * ((z1).val)) * (pow((z2).val,((z1).val) - ((float)(1.0))))) + ((((z1).dval) * (pow((z2).val,(z1).val))) * (log((z2).val))))
	z4 : _dfloat = make__dfloat(exp((z3).val),((z3).dval) * (exp((z3).val)))
	z5 : _dfloat = make__dfloat(log(((z3).val) + ((z4).val)),(((z3).dval) + ((z4).dval)) / (((z3).val) + ((z4).val)))
	return make__dfloat((z5).val,(z5).dval)

Generated C code:

#include <math.h>
        
typedef struct {
	float val;
	float dval;
} _dfloat;
float call(float x);
_dfloat d_call(_dfloat x);
_dfloat make__dfloat(float val, float dval);
float call(float x) {
	float z0 = sinf(x);
	float z1 = (cosf(z0)) + ((float)(1.0));
	float z2 = sqrtf(z1);
	float z3 = powf(z2,z1);
	float z4 = expf(z3);
	float z5 = logf((z3) + (z4));
	return z5;
}
_dfloat d_call(_dfloat x) {
	_dfloat z0 = make__dfloat(sinf((x).val),(cosf((x).val)) * ((x).dval));
	_dfloat z1 = make__dfloat((cosf((z0).val)) + ((float)(1.0)),(((sinf((z0).val)) * ((z0).dval)) * ((float)(-1.0))) + ((float)(0.0)));
	_dfloat z2 = make__dfloat(sqrtf((z1).val),(((float)(0.5)) * ((z1).dval)) / (sqrtf((z1).val)));
	_dfloat z3 = make__dfloat(powf((z2).val,(z1).val),((((z2).dval) * ((z1).val)) * (powf((z2).val,((z1).val) - ((float)(1.0))))) + ((((z1).dval) * (powf((z2).val,(z1).val))) * (logf((z2).val))));
	_dfloat z4 = make__dfloat(expf((z3).val),((z3).dval) * (expf((z3).val)));
	_dfloat z5 = make__dfloat(logf(((z3).val) + ((z4).val)),(((z3).dval) + ((z4).dval)) / (((z3).val) + ((z4).val)));
	return make__dfloat((z5).val,(z5).dval);
}
_dfloat make__dfloat(float val, float dval) {
	_dfloat ret;
	ret.val = 0;
	ret.dval = 0;
	(ret).val = val;
	(ret).dval = dval;
	return ret;
}


Forward differentiation of function d_call_cos:
def d_call_cos(x : In[_dfloat]) -> _dfloat:
	return make__dfloat(cos((x).val),((sin((x).val)) * ((x).dval)) * ((float)(-1.0)))

Generated C code:

#include <math.h>
        
typedef struct {
	float val;
	float dval;
} _dfloat;
float call_cos(float x);
_dfloat d_call_cos(_dfloat x);
_dfloat make__dfloat(float val, float dval);
float call_cos(float x) {
	return cosf(x);
}
_dfloat d_call_cos(_dfloat x) {
	return make__dfloat(cosf((x).val),((sinf((x).val)) * ((x).dval)) * ((float)(-1.0)));
}
_dfloat make__dfloat(float val, float dval) {
	_dfloat ret;
	ret.val = 0;
	ret.dval = 0;
	(ret).val = val;
	(ret).dval = dval;
	return ret;
}


Forward differentiation of function d_call_exp:
def d_call_exp(x : In[_dfloat]) -> _dfloat:
	return make__dfloat(exp((x).val),((x).dval) * (exp((x).val)))

Generated C code:

#include <math.h>
        
typedef struct {
	float val;
	float dval;
} _dfloat;
float call_exp(float x);
_dfloat d_call_exp(_dfloat x);
_dfloat make__dfloat(float val, float dval);
float call_exp(float x) {
	return expf(x);
}
_dfloat d_call_exp(_dfloat x) {
	return make__dfloat(expf((x).val),((x).dval) * (expf((x).val)));
}
_dfloat make__dfloat(float val, float dval) {
	_dfloat ret;
	ret.val = 0;
	ret.dval = 0;
	(ret).val = val;
	(ret).dval = dval;
	return ret;
}


Forward differentiation of function d_call_log:
def d_call_log(x : In[_dfloat]) -> _dfloat:
	return make__dfloat(log((x).val),((x).dval) / ((x).val))

Generated C code:

#include <math.h>
        
typedef struct {
	float val;
	float dval;
} _dfloat;
float call_log(float x);
_dfloat d_call_log(_dfloat x);
_dfloat make__dfloat(float val, float dval);
float call_log(float x) {
	return logf(x);
}
_dfloat d_call_log(_dfloat x) {
	return make__dfloat(logf((x).val),((x).dval) / ((x).val));
}
_dfloat make__dfloat(float val, float dval) {
	_dfloat ret;
	ret.val = 0;
	ret.dval = 0;
	(ret).val = val;
	(ret).dval = dval;
	return ret;
}


Forward differentiation of function d_call_pow:
def d_call_pow(x : In[_dfloat], y : In[_dfloat]) -> _dfloat:
	return make__dfloat(pow((x).val,(y).val),((((x).dval) * ((y).val)) * (pow((x).val,((y).val) - ((float)(1.0))))) + ((((y).dval) * (pow((x).val,(y).val))) * (log((x).val))))

Generated C code:

#include <math.h>
        
typedef struct {
	float val;
	float dval;
} _dfloat;
float call_pow(float x, float y);
_dfloat d_call_pow(_dfloat x, _dfloat y);
_dfloat make__dfloat(float val, float dval);
float call_pow(float x, float y) {
	return powf(x,y);
}
_dfloat d_call_pow(_dfloat x, _dfloat y) {
	return make__dfloat(powf((x).val,(y).val),((((x).dval) * ((y).val)) * (powf((x).val,((y).val) - ((float)(1.0))))) + ((((y).dval) * (powf((x).val,(y).val))) * (logf((x).val))));
}
_dfloat make__dfloat(float val, float dval) {
	_dfloat ret;
	ret.val = 0;
	ret.dval = 0;
	(ret).val = val;
	(ret).dval = dval;
	return ret;
}


Forward differentiation of function d_call_sin:
def d_call_sin(x : In[_dfloat]) -> _dfloat:
	return make__dfloat(sin((x).val),(cos((x).val)) * ((x).dval))

Generated C code:

#include <math.h>
        
typedef struct {
	float val;
	float dval;
} _dfloat;
float call_sin(float x);
_dfloat d_call_sin(_dfloat x);
_dfloat make__dfloat(float val, float dval);
float call_sin(float x) {
	return sinf(x);
}
_dfloat d_call_sin(_dfloat x) {
	return make__dfloat(sinf((x).val),(cosf((x).val)) * ((x).dval));
}
_dfloat make__dfloat(float val, float dval) {
	_dfloat ret;
	ret.val = 0;
	ret.dval = 0;
	(ret).val = val;
	(ret).dval = dval;
	return ret;
}


Forward differentiation of function d_call_sqrt:
def d_call_sqrt(x : In[_dfloat]) -> _dfloat:
	return make__dfloat(sqrt((x).val),(((float)(0.5)) * ((x).dval)) / (sqrt((x).val)))

Generated C code:

#include <math.h>
        
typedef struct {
	float val;
	float dval;
} _dfloat;
float call_sqrt(float x);
_dfloat d_call_sqrt(_dfloat x);
_dfloat make__dfloat(float val, float dval);
float call_sqrt(float x) {
	return sqrtf(x);
}
_dfloat d_call_sqrt(_dfloat x) {
	return make__dfloat(sqrtf((x).val),(((float)(0.5)) * ((x).dval)) / (sqrtf((x).val)));
}
_dfloat make__dfloat(float val, float dval) {
	_dfloat ret;
	ret.val = 0;
	ret.dval = 0;
	(ret).val = val;
	(ret).dval = dval;
	return ret;
}


Forward differentiation of function d_constant:
def d_constant(x : In[_dfloat]) -> _dfloat:
	return make__dfloat((float)(2.0),(float)(0.0))

Generated C code:

#include <math.h>
        
typedef struct {
	float val;
	float dval;
} _dfloat;
float constant(float x);
_dfloat d_constant(_dfloat x);
_dfloat make__dfloat(float val, float dval);
float constant(float x) {
	return (float)(2.0);
}
_dfloat d_constant(_dfloat x) {
	return make__dfloat((float)(2.0),(float)(0.0));
}
_dfloat make__dfloat(float val, float dval) {
	_dfloat ret;
	ret.val = 0;
	ret.dval = 0;
	(ret).val = val;
	(ret).dval = dval;
	return ret;
}


Forward differentiation of function d_declare:
def d_declare(x : In[_dfloat], y : In[_dfloat]) -> _dfloat:
	z0 : _dfloat = make__dfloat(((x).val) + ((y).val),((x).dval) + ((y).dval))
	z1 : _dfloat = make__dfloat(((z0).val) + ((float)(5.0)),((z0).dval) + ((float)(0.0)))
	z2 : _dfloat = make__dfloat(((z1).val) * ((z0).val),(((z1).val) * ((z0).dval)) + (((z1).dval) * ((z0).val)))
	return make__dfloat((z2).val,(z2).dval)

Generated C code:

#include <math.h>
        
typedef struct {
	float val;
	float dval;
} _dfloat;
float declare(float x, float y);
_dfloat d_declare(_dfloat x, _dfloat y);
_dfloat make__dfloat(float val, float dval);
float declare(float x, float y) {
	float z0 = (x) + (y);
	float z1 = (z0) + ((float)(5.0));
	float z2 = (z1) * (z0);
	return z2;
}
_dfloat d_declare(_dfloat x, _dfloat y) {
	_dfloat z0 = make__dfloat(((x).val) + ((y).val),((x).dval) + ((y).dval));
	_dfloat z1 = make__dfloat(((z0).val) + ((float)(5.0)),((z0).dval) + ((float)(0.0)));
	_dfloat z2 = make__dfloat(((z1).val) * ((z0).val),(((z1).val) * ((z0).dval)) + (((z1).dval) * ((z0).val)));
	return make__dfloat((z2).val,(z2).dval);
}
_dfloat make__dfloat(float val, float dval) {
	_dfloat ret;
	ret.val = 0;
	ret.dval = 0;
	(ret).val = val;
	(ret).dval = dval;
	return ret;
}


Forward differentiation of function d_divide:
def d_divide(x : In[_dfloat], y : In[_dfloat]) -> _dfloat:
	return make__dfloat(((x).val) / ((y).val),((((x).dval) * ((y).val)) - (((x).val) * ((y).dval))) / (((y).val) * ((y).val)))

Generated C code:

#include <math.h>
        
typedef struct {
	float val;
	float dval;
} _dfloat;
float divide(float x, float y);
_dfloat d_divide(_dfloat x, _dfloat y);
_dfloat make__dfloat(float val, float dval);
float divide(float x, float y) {
	return (x) / (y);
}
_dfloat d_divide(_dfloat x, _dfloat y) {
	return make__dfloat(((x).val) / ((y).val),((((x).dval) * ((y).val)) - (((x).val) * ((y).dval))) / (((y).val) * ((y).val)));
}
_dfloat make__dfloat(float val, float dval) {
	_dfloat ret;
	ret.val = 0;
	ret.dval = 0;
	(ret).val = val;
	(ret).dval = dval;
	return ret;
}


Forward differentiation of function d_identity:
def d_identity(x : In[_dfloat]) -> _dfloat:
	return make__dfloat((x).val,(x).dval)

Generated C code:

#include <math.h>
        
typedef struct {
	float val;
	float dval;
} _dfloat;
float identity(float x);
_dfloat d_identity(_dfloat x);
_dfloat make__dfloat(float val, float dval);
float identity(float x) {
	return x;
}
_dfloat d_identity(_dfloat x) {
	return make__dfloat((x).val,(x).dval);
}
_dfloat make__dfloat(float val, float dval) {
	_dfloat ret;
	ret.val = 0;
	ret.dval = 0;
	(ret).val = val;
	(ret).dval = dval;
	return ret;
}


Forward differentiation of function d_int_array_input:
def d_int_array_input(x : In[Array[_dfloat]], y : In[Array[int]]) -> _dfloat:
	return make__dfloat(((((x)[(int)(0)]).val) + (((x)[(int)(1)]).val)) + (int2float((y)[(int)(0)])),((((x)[(int)(0)]).dval) + (((x)[(int)(1)]).dval)) + ((float)(0.0)))

Generated C code:

#include <math.h>
        
typedef struct {
	float val;
	float dval;
} _dfloat;
float int_array_input(float* x, int* y);
_dfloat d_int_array_input(_dfloat* x, int* y);
_dfloat make__dfloat(float val, float dval);
float int_array_input(float* x, int* y) {
	return (((x)[(int)(0)]) + ((x)[(int)(1)])) + ((float)((y)[(int)(0)]));
}
_dfloat d_int_array_input(_dfloat* x, int* y) {
	return make__dfloat(((((x)[(int)(0)]).val) + (((x)[(int)(1)]).val)) + ((float)((y)[(int)(0)])),((((x)[(int)(0)]).dval) + (((x)[(int)(1)]).dval)) + ((float)(0.0)));
}
_dfloat make__dfloat(float val, float dval) {
	_dfloat ret;
	ret.val = 0;
	ret.dval = 0;
	(ret).val = val;
	(ret).dval = dval;
	return ret;
}


Forward differentiation of function d_int_input:
def d_int_input(x : In[_dfloat], y : In[int]) -> _dfloat:
	z : int = (int)(5)
	return make__dfloat((((int2float(z)) * ((x).val)) + (int2float(y))) - (int2float((int)(1))),((((int2float(z)) * ((x).dval)) + (((float)(0.0)) * ((x).val))) + ((float)(0.0))) - ((float)(0.0)))

Generated C code:

#include <math.h>
        
typedef struct {
	float val;
	float dval;
} _dfloat;
float int_input(float x, int y);
_dfloat d_int_input(_dfloat x, int y);
_dfloat make__dfloat(float val, float dval);
float int_input(float x, int y) {
	int z = (int)(5);
	return ((((float)(z)) * (x)) + ((float)(y))) - ((float)((int)(1)));
}
_dfloat d_int_input(_dfloat x, int y) {
	int z = (int)(5);
	return make__dfloat(((((float)(z)) * ((x).val)) + ((float)(y))) - ((float)((int)(1))),(((((float)(z)) * ((x).dval)) + (((float)(0.0)) * ((x).val))) + ((float)(0.0))) - ((float)(0.0)));
}
_dfloat make__dfloat(float val, float dval) {
	_dfloat ret;
	ret.val = 0;
	ret.dval = 0;
	(ret).val = val;
	(ret).dval = dval;
	return ret;
}


Forward differentiation of function d_int_output:
def d_int_output(x : In[_dfloat], y : In[int]) -> int:
	z : int = (int)(5)
	return float2int((((int2float(z)) * ((x).val)) + (int2float(y))) - (int2float((int)(1))))

Generated C code:

#include <math.h>
        
typedef struct {
	float val;
	float dval;
} _dfloat;
int int_output(float x, int y);
int d_int_output(_dfloat x, int y);
_dfloat make__dfloat(float val, float dval);
int int_output(float x, int y) {
	int z = (int)(5);
	return (int)(((((float)(z)) * (x)) + ((float)(y))) - ((float)((int)(1))));
}
int d_int_output(_dfloat x, int y) {
	int z = (int)(5);
	return (int)(((((float)(z)) * ((x).val)) + ((float)(y))) - ((float)((int)(1))));
}
_dfloat make__dfloat(float val, float dval) {
	_dfloat ret;
	ret.val = 0;
	ret.dval = 0;
	(ret).val = val;
	(ret).dval = dval;
	return ret;
}


Forward differentiation of function d_multiple_outputs:
def d_multiple_outputs(x : In[_dfloat], y : Out[Array[_dfloat]], z : Out[Array[_dfloat]]) -> void:
	(y)[(int)(0)] = make__dfloat(((x).val) * ((x).val),(((x).val) * ((x).dval)) + (((x).dval) * ((x).val)))
	(y)[(int)(1)] = make__dfloat((((x).val) * ((x).val)) * ((x).val),((((x).val) * ((x).val)) * ((x).dval)) + (((((x).val) * ((x).dval)) + (((x).dval) * ((x).val))) * ((x).val)))
	(z)[(int)(0)] = make__dfloat((((y)[(int)(0)]).val) * (((y)[(int)(1)]).val),((((y)[(int)(0)]).val) * (((y)[(int)(1)]).dval)) + ((((y)[(int)(0)]).dval) * (((y)[(int)(1)]).val)))

Generated C code:

#include <math.h>
        
typedef struct {
	float val;
	float dval;
} _dfloat;
void multiple_outputs(float x, float* y, float* z);
void d_multiple_outputs(_dfloat x, _dfloat* y, _dfloat* z);
_dfloat make__dfloat(float val, float dval);
void multiple_outputs(float x, float* y, float* z) {
	(y)[(int)(0)] = (x) * (x);
	(y)[(int)(1)] = ((x) * (x)) * (x);
	(z)[(int)(0)] = ((y)[(int)(0)]) * ((y)[(int)(1)]);
}
void d_multiple_outputs(_dfloat x, _dfloat* y, _dfloat* z) {
	(y)[(int)(0)] = make__dfloat(((x).val) * ((x).val),(((x).val) * ((x).dval)) + (((x).dval) * ((x).val)));
	(y)[(int)(1)] = make__dfloat((((x).val) * ((x).val)) * ((x).val),((((x).val) * ((x).val)) * ((x).dval)) + (((((x).val) * ((x).dval)) + (((x).dval) * ((x).val))) * ((x).val)));
	(z)[(int)(0)] = make__dfloat((((y)[(int)(0)]).val) * (((y)[(int)(1)]).val),((((y)[(int)(0)]).val) * (((y)[(int)(1)]).dval)) + ((((y)[(int)(0)]).dval) * (((y)[(int)(1)]).val)));
}
_dfloat make__dfloat(float val, float dval) {
	_dfloat ret;
	ret.val = 0;
	ret.dval = 0;
	(ret).val = val;
	(ret).dval = dval;
	return ret;
}


Forward differentiation of function d_multiply:
def d_multiply(x : In[_dfloat], y : In[_dfloat]) -> _dfloat:
	return make__dfloat(((x).val) * ((y).val),(((x).val) * ((y).dval)) + (((x).dval) * ((y).val)))

Generated C code:

#include <math.h>
        
typedef struct {
	float val;
	float dval;
} _dfloat;
float multiply(float x, float y);
_dfloat d_multiply(_dfloat x, _dfloat y);
_dfloat make__dfloat(float val, float dval);
float multiply(float x, float y) {
	return (x) * (y);
}
_dfloat d_multiply(_dfloat x, _dfloat y) {
	return make__dfloat(((x).val) * ((y).val),(((x).val) * ((y).dval)) + (((x).dval) * ((y).val)));
}
_dfloat make__dfloat(float val, float dval) {
	_dfloat ret;
	ret.val = 0;
	ret.dval = 0;
	(ret).val = val;
	(ret).dval = dval;
	return ret;
}


Forward differentiation of function d_nested_struct_input:
def d_nested_struct_input(foo : In[_dFoo]) -> _dfloat:
	b : _dBar
	(b).z = (int)(5)
	(b).w = make__dfloat(int2float((int)(3)),(float)(0.0))
	return make__dfloat(((((((foo).x).val) + (int2float(((foo).y).z))) + ((((foo).y).w).val)) + (int2float((b).z))) * (((b).w).val),(((((((foo).x).val) + (int2float(((foo).y).z))) + ((((foo).y).w).val)) + (int2float((b).z))) * (((b).w).dval)) + (((((((foo).x).dval) + ((float)(0.0))) + ((((foo).y).w).dval)) + ((float)(0.0))) * (((b).w).val)))

Generated C code:

#include <math.h>
        
typedef struct {
	int z;
	float w;
} Bar;
typedef struct {
	float x;
	Bar y;
} Foo;
typedef struct {
	float val;
	float dval;
} _dfloat;
typedef struct {
	int z;
	_dfloat w;
} _dBar;
typedef struct {
	_dfloat x;
	_dBar y;
} _dFoo;
float nested_struct_input(Foo foo);
_dfloat d_nested_struct_input(_dFoo foo);
_dfloat make__dfloat(float val, float dval);
float nested_struct_input(Foo foo) {
	Bar b;
	b.z = 0;
	b.w = 0;
	(b).z = (int)(5);
	(b).w = (float)((int)(3));
	return (((((foo).x) + ((float)(((foo).y).z))) + (((foo).y).w)) + ((float)((b).z))) * ((b).w);
}
_dfloat d_nested_struct_input(_dFoo foo) {
	_dBar b;
	b.z = 0;
	b.w.val = 0;
	b.w.dval = 0;
	(b).z = (int)(5);
	(b).w = make__dfloat((float)((int)(3)),(float)(0.0));
	return make__dfloat(((((((foo).x).val) + ((float)(((foo).y).z))) + ((((foo).y).w).val)) + ((float)((b).z))) * (((b).w).val),(((((((foo).x).val) + ((float)(((foo).y).z))) + ((((foo).y).w).val)) + ((float)((b).z))) * (((b).w).dval)) + (((((((foo).x).dval) + ((float)(0.0))) + ((((foo).y).w).dval)) + ((float)(0.0))) * (((b).w).val)));
}
_dfloat make__dfloat(float val, float dval) {
	_dfloat ret;
	ret.val = 0;
	ret.dval = 0;
	(ret).val = val;
	(ret).dval = dval;
	return ret;
}


Forward differentiation of function d_nested_struct_output:
def d_nested_struct_output(a : In[_dfloat], bar : Out[Array[_dBar]]) -> _dFoo:
	f : _dFoo
	(f).x = make__dfloat((int2float((int)(2))) * ((a).val),((int2float((int)(2))) * ((a).dval)) + (((float)(0.0)) * ((a).val)))
	((f).y).z = (int)(5)
	((f).y).w = make__dfloat(((f).x).val,((f).x).dval)
	((bar)[(int)(0)]).z = (int)(3)
	((bar)[(int)(0)]).w = make__dfloat((int2float(((bar)[(int)(0)]).z)) * ((a).val),((int2float(((bar)[(int)(0)]).z)) * ((a).dval)) + (((float)(0.0)) * ((a).val)))
	return f

Generated C code:

#include <math.h>
        
typedef struct {
	int z;
	float w;
} Bar;
typedef struct {
	float x;
	Bar y;
} Foo;
typedef struct {
	float val;
	float dval;
} _dfloat;
typedef struct {
	int z;
	_dfloat w;
} _dBar;
typedef struct {
	_dfloat x;
	_dBar y;
} _dFoo;
Foo nested_struct_output(float a, Bar* bar);
_dFoo d_nested_struct_output(_dfloat a, _dBar* bar);
_dfloat make__dfloat(float val, float dval);
Foo nested_struct_output(float a, Bar* bar) {
	Foo f;
	f.x = 0;
	f.y.z = 0;
	f.y.w = 0;
	(f).x = ((float)((int)(2))) * (a);
	((f).y).z = (int)(5);
	((f).y).w = (f).x;
	((bar)[(int)(0)]).z = (int)(3);
	((bar)[(int)(0)]).w = ((float)(((bar)[(int)(0)]).z)) * (a);
	return f;
}
_dFoo d_nested_struct_output(_dfloat a, _dBar* bar) {
	_dFoo f;
	f.x.val = 0;
	f.x.dval = 0;
	f.y.z = 0;
	f.y.w.val = 0;
	f.y.w.dval = 0;
	(f).x = make__dfloat(((float)((int)(2))) * ((a).val),(((float)((int)(2))) * ((a).dval)) + (((float)(0.0)) * ((a).val)));
	((f).y).z = (int)(5);
	((f).y).w = make__dfloat(((f).x).val,((f).x).dval);
	((bar)[(int)(0)]).z = (int)(3);
	((bar)[(int)(0)]).w = make__dfloat(((float)(((bar)[(int)(0)]).z)) * ((a).val),(((float)(((bar)[(int)(0)]).z)) * ((a).dval)) + (((float)(0.0)) * ((a).val)));
	return f;
}
_dfloat make__dfloat(float val, float dval) {
	_dfloat ret;
	ret.val = 0;
	ret.dval = 0;
	(ret).val = val;
	(ret).dval = dval;
	return ret;
}


Forward differentiation of function d_plus:
def d_plus(x : In[_dfloat], y : In[_dfloat]) -> _dfloat:
	return make__dfloat(((x).val) + ((y).val),((x).dval) + ((y).dval))

Generated C code:

#include <math.h>
        
typedef struct {
	float val;
	float dval;
} _dfloat;
float plus(float x, float y);
_dfloat d_plus(_dfloat x, _dfloat y);
_dfloat make__dfloat(float val, float dval);
float plus(float x, float y) {
	return (x) + (y);
}
_dfloat d_plus(_dfloat x, _dfloat y) {
	return make__dfloat(((x).val) + ((y).val),((x).dval) + ((y).dval));
}
_dfloat make__dfloat(float val, float dval) {
	_dfloat ret;
	ret.val = 0;
	ret.dval = 0;
	(ret).val = val;
	(ret).dval = dval;
	return ret;
}


Forward differentiation of function d_poly:
def d_poly(x : In[_dfloat]) -> _dfloat:
	return make__dfloat(((((((int2float((int)(3))) * ((x).val)) * ((x).val)) * ((x).val)) * ((x).val)) + (((int2float((int)(5))) * ((x).val)) * ((x).val))) + (int2float((int)(10))),(((((((int2float((int)(3))) * ((x).val)) * ((x).val)) * ((x).val)) * ((x).dval)) + ((((((int2float((int)(3))) * ((x).val)) * ((x).val)) * ((x).dval)) + (((((int2float((int)(3))) * ((x).val)) * ((x).dval)) + ((((int2float((int)(3))) * ((x).dval)) + (((float)(0.0)) * ((x).val))) * ((x).val))) * ((x).val))) * ((x).val))) + ((((int2float((int)(5))) * ((x).val)) * ((x).dval)) + ((((int2float((int)(5))) * ((x).dval)) + (((float)(0.0)) * ((x).val))) * ((x).val)))) + ((float)(0.0)))

Generated C code:

#include <math.h>
        
typedef struct {
	float val;
	float dval;
} _dfloat;
float poly(float x);
_dfloat d_poly(_dfloat x);
float d_poly_dx(float x);
_dfloat make__dfloat(float val, float dval);
float poly(float x) {
	return (((((((float)((int)(3))) * (x)) * (x)) * (x)) * (x)) + ((((float)((int)(5))) * (x)) * (x))) + ((float)((int)(10)));
}
_dfloat d_poly(_dfloat x) {
	return make__dfloat((((((((float)((int)(3))) * ((x).val)) * ((x).val)) * ((x).val)) * ((x).val)) + ((((float)((int)(5))) * ((x).val)) * ((x).val))) + ((float)((int)(10))),((((((((float)((int)(3))) * ((x).val)) * ((x).val)) * ((x).val)) * ((x).dval)) + (((((((float)((int)(3))) * ((x).val)) * ((x).val)) * ((x).dval)) + ((((((float)((int)(3))) * ((x).val)) * ((x).dval)) + (((((float)((int)(3))) * ((x).dval)) + (((float)(0.0)) * ((x).val))) * ((x).val))) * ((x).val))) * ((x).val))) + (((((float)((int)(5))) * ((x).val)) * ((x).dval)) + (((((float)((int)(5))) * ((x).dval)) + (((float)(0.0)) * ((x).val))) * ((x).val)))) + ((float)(0.0)));
}
float d_poly_dx(float x) {
	_dfloat d_x;
	d_x.val = 0;
	d_x.dval = 0;
	(d_x).val = x;
	(d_x).dval = (float)(1.0);
	return (d_poly(d_x)).dval;
}
_dfloat make__dfloat(float val, float dval) {
	_dfloat ret;
	ret.val = 0;
	ret.dval = 0;
	(ret).val = val;
	(ret).dval = dval;
	return ret;
}


Forward differentiation of function d_side_effect:
def d_side_effect(x : In[_dfloat], y : In[_dfloat]) -> _dfloat:
	z : _dfloat
	z = make__dfloat(((x).val) + ((y).val),((x).dval) + ((y).dval))
	z = make__dfloat((float)(0.0),(float)(0.0))
	z = make__dfloat(((x).val) * ((y).val),(((x).val) * ((y).dval)) + (((x).dval) * ((y).val)))
	return make__dfloat((z).val,(z).dval)

Generated C code:

#include <math.h>
        
typedef struct {
	float val;
	float dval;
} _dfloat;
float side_effect(float x, float y);
_dfloat d_side_effect(_dfloat x, _dfloat y);
_dfloat make__dfloat(float val, float dval);
float side_effect(float x, float y) {
	float z;
	z = 0;
	z = (x) + (y);
	z = (float)(0.0);
	z = (x) * (y);
	return z;
}
_dfloat d_side_effect(_dfloat x, _dfloat y) {
	_dfloat z;
	z.val = 0;
	z.dval = 0;
	z = make__dfloat(((x).val) + ((y).val),((x).dval) + ((y).dval));
	z = make__dfloat((float)(0.0),(float)(0.0));
	z = make__dfloat(((x).val) * ((y).val),(((x).val) * ((y).dval)) + (((x).dval) * ((y).val)));
	return make__dfloat((z).val,(z).dval);
}
_dfloat make__dfloat(float val, float dval) {
	_dfloat ret;
	ret.val = 0;
	ret.dval = 0;
	(ret).val = val;
	(ret).dval = dval;
	return ret;
}


Forward differentiation of function d_struct_assign:
def d_struct_assign(f : In[_dFoo]) -> _dFoo:
	foo : _dFoo
	foo = f
	(foo).a = make__dfloat((((foo).a).val) * (int2float((int)(2))),((((foo).a).val) * ((float)(0.0))) + ((((foo).a).dval) * (int2float((int)(2)))))
	return foo

Generated C code:

#include <math.h>
        
typedef struct {
	float a;
	int b;
} Foo;
typedef struct {
	float val;
	float dval;
} _dfloat;
typedef struct {
	_dfloat a;
	int b;
} _dFoo;
Foo struct_assign(Foo f);
_dFoo d_struct_assign(_dFoo f);
_dfloat make__dfloat(float val, float dval);
Foo struct_assign(Foo f) {
	Foo foo;
	foo.a = 0;
	foo.b = 0;
	foo = f;
	(foo).a = ((foo).a) * ((float)((int)(2)));
	return foo;
}
_dFoo d_struct_assign(_dFoo f) {
	_dFoo foo;
	foo.a.val = 0;
	foo.a.dval = 0;
	foo.b = 0;
	foo = f;
	(foo).a = make__dfloat((((foo).a).val) * ((float)((int)(2))),((((foo).a).val) * ((float)(0.0))) + ((((foo).a).dval) * ((float)((int)(2)))));
	return foo;
}
_dfloat make__dfloat(float val, float dval) {
	_dfloat ret;
	ret.val = 0;
	ret.dval = 0;
	(ret).val = val;
	(ret).dval = dval;
	return ret;
}


Forward differentiation of function d_struct_declare:
def d_struct_declare(f : In[_dFoo]) -> _dFoo:
	foo : _dFoo = f
	(foo).a = make__dfloat((((foo).a).val) * (int2float((int)(2))),((((foo).a).val) * ((float)(0.0))) + ((((foo).a).dval) * (int2float((int)(2)))))
	return foo

Generated C code:

#include <math.h>
        
typedef struct {
	float a;
	int b;
} Foo;
typedef struct {
	float val;
	float dval;
} _dfloat;
typedef struct {
	_dfloat a;
	int b;
} _dFoo;
Foo struct_declare(Foo f);
_dFoo d_struct_declare(_dFoo f);
_dfloat make__dfloat(float val, float dval);
Foo struct_declare(Foo f) {
	Foo foo = f;
	(foo).a = ((foo).a) * ((float)((int)(2)));
	return foo;
}
_dFoo d_struct_declare(_dFoo f) {
	_dFoo foo = f;
	(foo).a = make__dfloat((((foo).a).val) * ((float)((int)(2))),((((foo).a).val) * ((float)(0.0))) + ((((foo).a).dval) * ((float)((int)(2)))));
	return foo;
}
_dfloat make__dfloat(float val, float dval) {
	_dfloat ret;
	ret.val = 0;
	ret.dval = 0;
	(ret).val = val;
	(ret).dval = dval;
	return ret;
}


Forward differentiation of function d_struct_in_array:
def d_struct_in_array(in_f : In[Array[_dFoo]], out_f : Out[Array[_dFoo]]) -> void:
	((out_f)[(int)(0)]).x = float2int((int2float(((in_f)[(int)(0)]).x)) * ((((in_f)[(int)(0)]).y).val))
	((out_f)[(int)(0)]).y = make__dfloat((int2float(((in_f)[(int)(0)]).x)) + ((((in_f)[(int)(0)]).y).val),((float)(0.0)) + ((((in_f)[(int)(0)]).y).dval))

Generated C code:

#include <math.h>
        
typedef struct {
	int x;
	float y;
} Foo;
typedef struct {
	float val;
	float dval;
} _dfloat;
typedef struct {
	int x;
	_dfloat y;
} _dFoo;
void struct_in_array(Foo* in_f, Foo* out_f);
void d_struct_in_array(_dFoo* in_f, _dFoo* out_f);
_dfloat make__dfloat(float val, float dval);
void struct_in_array(Foo* in_f, Foo* out_f) {
	((out_f)[(int)(0)]).x = (int)(((float)(((in_f)[(int)(0)]).x)) * (((in_f)[(int)(0)]).y));
	((out_f)[(int)(0)]).y = ((float)(((in_f)[(int)(0)]).x)) + (((in_f)[(int)(0)]).y);
}
void d_struct_in_array(_dFoo* in_f, _dFoo* out_f) {
	((out_f)[(int)(0)]).x = (int)(((float)(((in_f)[(int)(0)]).x)) * ((((in_f)[(int)(0)]).y).val));
	((out_f)[(int)(0)]).y = make__dfloat(((float)(((in_f)[(int)(0)]).x)) + ((((in_f)[(int)(0)]).y).val),((float)(0.0)) + ((((in_f)[(int)(0)]).y).dval));
}
_dfloat make__dfloat(float val, float dval) {
	_dfloat ret;
	ret.val = 0;
	ret.dval = 0;
	(ret).val = val;
	(ret).dval = dval;
	return ret;
}


Forward differentiation of function d_struct_input:
def d_struct_input(foo : In[_dFoo]) -> _dfloat:
	z : int = (int)(5)
	return make__dfloat((((int2float(z)) * (((foo).x).val)) + (int2float((foo).y))) - (int2float((int)(1))),((((int2float(z)) * (((foo).x).dval)) + (((float)(0.0)) * (((foo).x).val))) + ((float)(0.0))) - ((float)(0.0)))

Generated C code:

#include <math.h>
        
typedef struct {
	float x;
	int y;
} Foo;
typedef struct {
	float val;
	float dval;
} _dfloat;
typedef struct {
	_dfloat x;
	int y;
} _dFoo;
float struct_input(Foo foo);
_dfloat d_struct_input(_dFoo foo);
_dfloat make__dfloat(float val, float dval);
float struct_input(Foo foo) {
	int z = (int)(5);
	return ((((float)(z)) * ((foo).x)) + ((float)((foo).y))) - ((float)((int)(1)));
}
_dfloat d_struct_input(_dFoo foo) {
	int z = (int)(5);
	return make__dfloat(((((float)(z)) * (((foo).x).val)) + ((float)((foo).y))) - ((float)((int)(1))),(((((float)(z)) * (((foo).x).dval)) + (((float)(0.0)) * (((foo).x).val))) + ((float)(0.0))) - ((float)(0.0)));
}
_dfloat make__dfloat(float val, float dval) {
	_dfloat ret;
	ret.val = 0;
	ret.dval = 0;
	(ret).val = val;
	(ret).dval = dval;
	return ret;
}


Forward differentiation of function d_struct_output:
def d_struct_output(x : In[_dfloat], y : In[int]) -> _dFoo:
	foo : _dFoo
	(foo).a = make__dfloat(((x).val) + ((int2float(y)) * ((x).val)),((x).dval) + (((int2float(y)) * ((x).dval)) + (((float)(0.0)) * ((x).val))))
	(foo).b = float2int((int2float(y)) - ((x).val))
	return foo

Generated C code:

#include <math.h>
        
typedef struct {
	float a;
	int b;
} Foo;
typedef struct {
	float val;
	float dval;
} _dfloat;
typedef struct {
	_dfloat a;
	int b;
} _dFoo;
Foo struct_output(float x, int y);
_dFoo d_struct_output(_dfloat x, int y);
_dfloat make__dfloat(float val, float dval);
Foo struct_output(float x, int y) {
	Foo foo;
	foo.a = 0;
	foo.b = 0;
	(foo).a = (x) + (((float)(y)) * (x));
	(foo).b = (int)(((float)(y)) - (x));
	return foo;
}
_dFoo d_struct_output(_dfloat x, int y) {
	_dFoo foo;
	foo.a.val = 0;
	foo.a.dval = 0;
	foo.b = 0;
	(foo).a = make__dfloat(((x).val) + (((float)(y)) * ((x).val)),((x).dval) + ((((float)(y)) * ((x).dval)) + (((float)(0.0)) * ((x).val))));
	(foo).b = (int)(((float)(y)) - ((x).val));
	return foo;
}
_dfloat make__dfloat(float val, float dval) {
	_dfloat ret;
	ret.val = 0;
	ret.dval = 0;
	(ret).val = val;
	(ret).dval = dval;
	return ret;
}


Forward differentiation of function d_subtract:
def d_subtract(x : In[_dfloat], y : In[_dfloat]) -> _dfloat:
	return make__dfloat(((x).val) - ((y).val),((x).dval) - ((y).dval))

Generated C code:

#include <math.h>
        
typedef struct {
	float val;
	float dval;
} _dfloat;
float subtract(float x, float y);
_dfloat d_subtract(_dfloat x, _dfloat y);
_dfloat make__dfloat(float val, float dval);
float subtract(float x, float y) {
	return (x) - (y);
}
_dfloat d_subtract(_dfloat x, _dfloat y) {
	return make__dfloat(((x).val) - ((y).val),((x).dval) - ((y).dval));
}
_dfloat make__dfloat(float val, float dval) {
	_dfloat ret;
	ret.val = 0;
	ret.dval = 0;
	(ret).val = val;
	(ret).dval = dval;
	return ret;
}

